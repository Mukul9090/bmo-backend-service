---
- name: Setup Kubernetes Infrastructure
  hosts: k8s_clusters
  gather_facts: true
  
  tasks:
    # ========== macOS Tasks ==========
    - name: Check if Homebrew is installed (macOS)
      command: which brew
      register: homebrew_check
      changed_when: false
      failed_when: false
      become: false
      when: ansible_system == "Darwin"
    
    - name: Install Homebrew (macOS)
      shell: |
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      when: 
        - ansible_system == "Darwin"
        - homebrew_check.rc != 0
      environment:
        NONINTERACTIVE: 1
      register: homebrew_install
    
    - name: Add Homebrew to PATH (macOS)
      lineinfile:
        path: "{{ ansible_env.HOME }}/.zshrc"
        line: 'eval "$(/opt/homebrew/bin/brew shellenv)"'
        create: yes
      when: 
        - ansible_system == "Darwin"
        - homebrew_check.rc != 0
      ignore_errors: yes
    
    - name: Add Homebrew to PATH for bash (macOS)
      lineinfile:
        path: "{{ ansible_env.HOME }}/.bash_profile"
        line: 'eval "$(/opt/homebrew/bin/brew shellenv)"'
        create: yes
      when: 
        - ansible_system == "Darwin"
        - homebrew_check.rc != 0
      ignore_errors: yes
    
    - name: Update Homebrew (macOS)
      community.general.homebrew:
        update_homebrew: yes
      become: false
      when: ansible_system == "Darwin"
    
    - name: Install required packages via Homebrew (macOS)
      community.general.homebrew:
        name:
          - curl
          - python3
        state: present
      become: false
      when: ansible_system == "Darwin"
    
    - name: Check if Docker Desktop is installed (macOS)
      stat:
        path: /Applications/Docker.app
      register: docker_desktop_exists
      become: false
      when: ansible_system == "Darwin"
    
    - name: Install Docker Desktop via Homebrew (macOS)
      community.general.homebrew_cask:
        name: docker
        state: present
      become: false
      when: 
        - ansible_system == "Darwin"
        - not docker_desktop_exists.stat.exists
    
    - name: Start Docker Desktop (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        open -a Docker
        # Wait for Docker to start
        max_wait=60
        elapsed=0
        while [ $elapsed -lt $max_wait ]; do
          if docker ps > /dev/null 2>&1; then
            exit 0
          fi
          sleep 2
          elapsed=$((elapsed + 2))
        done
        exit 1
      become: false
      when: ansible_system == "Darwin"
      register: docker_start
      until: docker_start.rc == 0
      retries: 15
      delay: 5
      ignore_errors: yes
    
    - name: Install kubectl via Homebrew (macOS)
      community.general.homebrew:
        name: kubectl
        state: present
      become: false
      when: ansible_system == "Darwin"
    
    - name: Install minikube via Homebrew (macOS)
      community.general.homebrew:
        name: minikube
        state: present
      become: false
      when: ansible_system == "Darwin"
    
    - name: Check if Minikube cluster exists (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        minikube status
      register: minikube_status
      changed_when: false
      failed_when: false
      become: false
      when: ansible_system == "Darwin"
    
    - name: Start Minikube cluster (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        minikube start --driver=docker
      become: false
      when: 
        - ansible_system == "Darwin"
        - minikube_status.rc != 0
      register: minikube_start
      until: minikube_start.rc == 0
      retries: 5
      delay: 10
      ignore_errors: yes
    
    - name: Wait for Minikube to be ready (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        minikube status
      register: minikube_ready
      until: "'Running' in minikube_ready.stdout"
      retries: 30
      delay: 5
      become: false
      when: ansible_system == "Darwin"
      ignore_errors: yes
    
    - name: Verify kubectl is in PATH (macOS)
      command: which kubectl
      register: kubectl_path_mac
      changed_when: false
      become: false
      when: ansible_system == "Darwin"
    
    - name: Display kubectl location (macOS)
      debug:
        msg: "kubectl installed at: {{ kubectl_path_mac.stdout }}"
      when: kubectl_path_mac is defined
    
    # ========== Linux Tasks ==========
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600
      become: true
      when: ansible_os_family == "Debian"
    
    - name: Install required packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - python3-pip
        state: present
      become: true
      when: ansible_os_family == "Debian"
    
    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Install Docker
      apt:
        name: docker-ce
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Enable and start Docker (Linux)
      systemd:
        name: docker
        enabled: yes
        state: started
      when: ansible_os_family == "Debian"
    
    - name: Add Kubernetes GPG key
      apt_key:
        url: https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Add Kubernetes repository
      apt_repository:
        repo: "deb [arch=amd64] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /"
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Install Kubernetes components
      apt:
        name:
          - kubelet={{ k8s_version }}-1.1
          - kubeadm={{ k8s_version }}-1.1
          - kubectl={{ k8s_version }}-1.1
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Verify kubectl is in PATH
      command: which kubectl
      register: kubectl_path
      changed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display kubectl location (macOS)
      debug:
        msg: "kubectl installed at: {{ kubectl_path_mac.stdout }}"
      when: 
        - kubectl_path_mac is defined
        - kubectl_path_mac.stdout is defined
    
    - name: Display kubectl location (Linux)
      debug:
        msg: "kubectl installed at: {{ kubectl_path.stdout }}"
      when: 
        - kubectl_path is defined
        - kubectl_path.stdout is defined
    
    - name: Configure sysctl for Kubernetes (Linux)
      sysctl:
        name: "{{ item.key }}"
        value: "{{ item.value }}"
        state: present
        sysctl_set: yes
        reload: yes
      loop:
        - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { key: 'net.ipv4.ip_forward', value: '1' }
      when: ansible_os_family == "Debian"
    
    # ========== Additional Network Configuration ==========
    - name: Make sysctl settings persistent
      lineinfile:
        path: /etc/sysctl.conf
        regexp: "^{{ item.key }}"
        line: "{{ item.key }} = {{ item.value }}"
        state: present
      loop:
        - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { key: 'net.ipv4.ip_forward', value: '1' }
      when: ansible_os_family == "Debian"
    
    - name: Load kernel modules persistently
      lineinfile:
        path: /etc/modules-load.d/k8s.conf
        line: "{{ item }}"
        create: yes
      loop:
        - br_netfilter
        - overlay
      when: ansible_os_family == "Debian"
    
    - name: Load kernel modules (Linux)
      modprobe:
        name: "{{ item }}"
        state: present
      loop:
        - br_netfilter
        - overlay
      when: ansible_os_family == "Debian"
    
    # ========== Firewall Configuration ==========
    - name: Install UFW firewall
      apt:
        name: ufw
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Set UFW default policies
      ufw:
        direction: "{{ item.direction }}"
        policy: "{{ item.policy }}"
      loop:
        - { direction: 'incoming', policy: 'deny' }
        - { direction: 'outgoing', policy: 'allow' }
        - { direction: 'routed', policy: 'allow' }
      when: ansible_os_family == "Debian"
    
    - name: Allow SSH
      ufw:
        rule: allow
        port: '22'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow Kubernetes API server
      ufw:
        rule: allow
        port: '6443'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow Kubelet API
      ufw:
        rule: allow
        port: '10250'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow Kube-scheduler
      ufw:
        rule: allow
        port: '10259'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow Kube-controller-manager
      ufw:
        rule: allow
        port: '10257'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow etcd client API
      ufw:
        rule: allow
        port: '2379'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow etcd peer API
      ufw:
        rule: allow
        port: '2380'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Allow NodePort range (30000-32767)
      ufw:
        rule: allow
        port: '30000:32767'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Enable UFW firewall
      ufw:
        state: enabled
      when: ansible_os_family == "Debian"
    
    - name: Verify UFW status
      command: ufw status verbose
      register: ufw_status
      changed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display firewall status
      debug:
        msg: "{{ ufw_status.stdout_lines }}"
      when: 
        - ufw_status is defined
        - ufw_status.stdout_lines is defined
    
    - name: Disable swap (Linux)
      command: swapoff -a
      changed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Comment out swap in /etc/fstab (Linux)
      replace:
        path: /etc/fstab
        regexp: '^([^#].*?\sswap\s+sw\s+)'
        replace: '#\1'
      when: ansible_os_family == "Debian"
    
    - name: Install security updates
      apt:
        upgrade: dist
        update_cache: yes
      when: ansible_os_family == "Debian"
      ignore_errors: yes
    
    # ========== Enhanced Security Patches ==========
    - name: Install unattended-upgrades for automatic security patches
      apt:
        name: unattended-upgrades
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Configure automatic security updates
      copy:
        content: |
          APT::Periodic::Update-Package-Lists "1";
          APT::Periodic::Unattended-Upgrade "1";
          APT::Periodic::Download-Upgradeable-Packages "1";
          APT::Periodic::AutocleanInterval "7";
          Unattended-Upgrade::Automatic-Reboot "false";
          Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
          Unattended-Upgrade::Remove-Unused-Dependencies "true";
        dest: /etc/apt/apt.conf.d/50unattended-upgrades
      when: ansible_os_family == "Debian"
    
    - name: Configure which packages to auto-upgrade
      copy:
        content: |
          Unattended-Upgrade::Allowed-Origins {
              "${distro_id}:${distro_codename}-security";
              "${distro_id}ESMApps:${distro_codename}-apps-security";
          };
          Unattended-Upgrade::Package-Blacklist {
          };
        dest: /etc/apt/apt.conf.d/50unattended-upgrades-security
      when: ansible_os_family == "Debian"
    
    - name: Enable automatic security updates service
      systemd:
        name: unattended-upgrades
        enabled: yes
        state: started
      when: ansible_os_family == "Debian"
    
    # ========== SSH Hardening ==========
    - name: Backup SSH configuration
      copy:
        src: /etc/ssh/sshd_config
        dest: /etc/ssh/sshd_config.backup
        remote_src: yes
      when: ansible_os_family == "Debian"
      ignore_errors: yes
    
    - name: Disable root login via SSH
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitRootLogin'
        line: 'PermitRootLogin no'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Disable password authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Enable public key authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PubkeyAuthentication'
        line: 'PubkeyAuthentication yes'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Disable empty passwords
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitEmptyPasswords'
        line: 'PermitEmptyPasswords no'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Set SSH protocol version
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?Protocol'
        line: 'Protocol 2'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Set SSH idle timeout
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?ClientAliveInterval'
        line: 'ClientAliveInterval 300'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Set SSH max authentication attempts
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?MaxAuthTries'
        line: 'MaxAuthTries 3'
        backup: yes
      when: ansible_os_family == "Debian"
      notify: restart sshd
    
    - name: Enable and start kubelet service
      systemd:
        name: kubelet
        enabled: yes
        state: started
      when: ansible_os_family == "Debian"
    
    - name: Create .kube directory
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /root/.kube
        - "{{ ansible_env.HOME }}/.kube"
      when: ansible_os_family == "Debian"
    
    - name: Check if cluster already initialized
      stat:
        path: /etc/kubernetes/admin.conf
      register: kubeconfig_exists
      when: ansible_os_family == "Debian"
    
    - name: Initialize Kubernetes cluster
      command: >
        kubeadm init
        --pod-network-cidr={{ pod_network_cidr }}
        --service-cidr={{ service_cidr }}
        --ignore-preflight-errors=Swap
        --apiserver-advertise-address=0.0.0.0
      when: 
        - ansible_os_family == "Debian"
        - not kubeconfig_exists.stat.exists
      register: kubeadm_init
      changed_when: kubeadm_init.rc == 0
    
    - name: Set up kubeconfig for root user
      copy:
        src: /etc/kubernetes/admin.conf
        dest: /root/.kube/config
        remote_src: yes
        mode: '0644'
        owner: root
        group: root
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Set up kubeconfig for current user
      copy:
        src: /etc/kubernetes/admin.conf
        dest: "{{ ansible_env.HOME }}/.kube/config"
        remote_src: yes
        mode: '0644'
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Install Calico CNI plugin
      command: kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml
      environment:
        KUBECONFIG: /root/.kube/config
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
      register: calico_install
      until: calico_install.rc == 0
      retries: 5
      delay: 5
      ignore_errors: yes
    
    - name: Wait for Calico pods to be ready
      command: kubectl wait --for=condition=ready pod -l k8s-app=calico-node -n kube-system --timeout=300s
      environment:
        KUBECONFIG: /root/.kube/config
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
      ignore_errors: yes
    
    - name: Wait for cluster to be ready
      command: kubectl get nodes
      register: cluster_status
      environment:
        KUBECONFIG: /root/.kube/config
      until: cluster_status.rc == 0
      retries: 30
      delay: 10
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Display cluster status
      command: kubectl get nodes -o wide
      environment:
        KUBECONFIG: /root/.kube/config
      register: nodes_status
      changed_when: false
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Show cluster info
      debug:
        msg: "{{ nodes_status.stdout_lines }}"
      when: 
        - nodes_status is defined
        - nodes_status.stdout_lines is defined
    
    - name: Verify kubectl is working
      command: kubectl version --client
      register: kubectl_version
      changed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display kubectl version
      debug:
        msg: "{{ kubectl_version.stdout_lines }}"
      when: 
        - kubectl_version is defined
        - kubectl_version.stdout_lines is defined
    
    - name: Verify cluster API is accessible
      command: kubectl cluster-info
      environment:
        KUBECONFIG: /root/.kube/config
      register: cluster_info
      changed_when: false
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Display cluster API endpoint
      debug:
        msg: "{{ cluster_info.stdout_lines }}"
      when: 
        - cluster_info is defined
        - cluster_info.stdout_lines is defined
    
    - name: Verify cluster can accept deployments
      command: kubectl get namespaces
      environment:
        KUBECONFIG: /root/.kube/config
      register: namespaces_check
      changed_when: false
      when: 
        - ansible_os_family == "Debian"
        - kubeconfig_exists.stat.exists or (kubeadm_init.rc == 0 and kubeadm_init.stdout is defined)
    
    - name: Display available namespaces
      debug:
        msg: "{{ namespaces_check.stdout_lines }}"
      when: 
        - namespaces_check is defined
        - namespaces_check.stdout_lines is defined
    
    # ========== Verification Tasks (Both macOS and Linux) ==========
    - name: Verify Docker is working
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        docker ps
      register: docker_check
      changed_when: false
      failed_when: false
      when: ansible_system == "Darwin"
    
    - name: Verify Docker is working (Linux)
      command: docker ps
      register: docker_check
      changed_when: false
      failed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display Docker status
      debug:
        msg: "Docker: {{ 'Running' if (docker_check.rc is defined and docker_check.rc == 0) else 'Not accessible' }}"
      when: 
        - docker_check is defined
        - docker_check.rc is defined
    
    - name: Verify kubectl is working (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        kubectl version --client
      register: kubectl_version_check
      changed_when: false
      failed_when: false
      when: ansible_system == "Darwin"
    
    - name: Verify kubectl is working (Linux)
      command: kubectl version --client
      register: kubectl_version_check
      changed_when: false
      failed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display kubectl version
      debug:
        msg: "{{ kubectl_version_check.stdout_lines }}"
      when: 
        - kubectl_version_check is defined
        - kubectl_version_check.stdout_lines is defined
    
    - name: Verify cluster API is accessible (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        kubectl cluster-info
      register: cluster_info_check
      changed_when: false
      failed_when: false
      when: ansible_system == "Darwin"
    
    - name: Verify cluster API is accessible (Linux)
      command: kubectl cluster-info
      environment:
        KUBECONFIG: /root/.kube/config
      register: cluster_info_check
      changed_when: false
      failed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display cluster API endpoint
      debug:
        msg: "{{ cluster_info_check.stdout_lines }}"
      when: 
        - cluster_info_check is defined
        - cluster_info_check.stdout_lines is defined
    
    - name: Verify cluster can accept deployments (macOS)
      shell: |
        export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
        kubectl get namespaces
      register: namespaces_check_final
      changed_when: false
      failed_when: false
      when: ansible_system == "Darwin"
    
    - name: Verify cluster can accept deployments (Linux)
      command: kubectl get namespaces
      environment:
        KUBECONFIG: /root/.kube/config
      register: namespaces_check_final
      changed_when: false
      failed_when: false
      when: ansible_os_family == "Debian"
    
    - name: Display available namespaces
      debug:
        msg: "{{ namespaces_check_final.stdout_lines }}"
      when: 
        - namespaces_check_final is defined
        - namespaces_check_final.stdout_lines is defined
    
  handlers:
    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
      when: ansible_os_family == "Debian"
    
    # ========== Summary Messages ==========
    - name: Summary - Infrastructure ready for GitHub Actions (Linux)
      debug:
        msg:
          - "âœ… Docker installed and running"
          - "âœ… Kubernetes tools installed (kubectl, kubeadm, kubelet)"
          - "âœ… Kubernetes cluster initialized"
          - "âœ… kubeconfig configured at /root/.kube/config"
          - "âœ… Calico CNI plugin installed"
          - "âœ… Cluster is ready to accept deployments"
          - ""
          - "ðŸ“‹ For GitHub Actions CI/CD:"
          - "   - Copy kubeconfig from /root/.kube/config to GitHub Actions runner"
          - "   - Or configure KUBECONFIG environment variable"
          - "   - Cluster API should be accessible from GitHub Actions runner"
      when: ansible_os_family == "Debian"
    
    - name: Summary - Infrastructure ready for GitHub Actions (macOS)
      debug:
        msg:
          - "âœ… Docker Desktop installed and running"
          - "âœ… Kubernetes tools installed (kubectl, minikube)"
          - "âœ… Minikube cluster initialized and running"
          - "âœ… kubeconfig configured via Minikube"
          - "âœ… Cluster is ready to accept deployments"
          - ""
          - "ðŸ“‹ For GitHub Actions CI/CD:"
          - "   - Minikube kubeconfig is at: ~/.kube/config"
          - "   - Or run: minikube kubectl -- get nodes"
          - "   - Cluster API should be accessible from GitHub Actions runner"
      when: ansible_system == "Darwin"

